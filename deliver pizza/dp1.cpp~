#include <cstdio>
#include <algorithm>
#include <utility>
#include <vector>
#include <queue>
 
#define MAXN 501
#define INF 1234567890
 
using namespace std;
 
typedef pair< int, int > pii;
 
struct node {
	int x,y;
};
 
int N,M;
node s;
vector< node > build;
int grid[ MAXN + 1 ][ MAXN + 1 ], isb[ MAXN + 1 ][ MAXN + 1 ], dist[ MAXN + 1 ][ MAXN + 1 ];
 
bool operator<( const node& a, const node& b )
{
	return dist[ a.x ][ a.y ] > dist[ b.x ][ b.y ];
}
 
void init()
{
	build.clear();
	for( int i = 1; i <= MAXN; i++ ) {
		for( int j = 1; j <= MAXN; j++ ) {
			grid[ i ][ j ] = 0;
			isb[ i ][ j ] = 0;
			dist[ i ][ j ] = INF;
		}
	}
}
	
node make_node( int x, int y )
{
	node a;
	a.x = x; a.y = y;
	return a;
}
 
priority_queue< node > pq;
 
void check( int x1, int y1, int x, int y )
{
	int d;
	if( abs( grid[ x1 ][ y1 ] - grid[ x ][ y ] ) > 1 && !isb[ x1 ][ y1 ] && !isb[ x ][ y ] ) {
		return;
	} else {
		if( isb[ x1 ][ y1 ] || isb[ x ][ y ]  ) {
			d = dist[ x1 ][ y1 ] + 2;
		} else {
			d = dist[ x1 ][ y1 ] + ( abs( grid[ x1 ][ y1 ] - grid[ x ][ y ] ) == 0 ? 1 : 3 );
		}
	}
	if( x > N || y > M || x <= 0 || y <= 0 || dist[ x ][ y ] <= d ) {
		return;
	}
	dist[ x ][ y ] = d;
	pq.push( make_node( x, y ) );
}
 
void dijkstra()
{
	pq.push( s );
	dist[ s.x ][ s.y ] = 0;
	while( !pq.empty() ) {
		node a = pq.top();
		pq.pop();
		check( a.x, a.y, a.x + 1, a.y );
		check( a.x, a.y, a.x - 1, a.y );
		check( a.x, a.y, a.x, a.y - 1 );
		check( a.x, a.y, a.x, a.y + 1 );
	}
}
 
int main( void )
{
	int C;
	scanf("%d", &C );
	while( C-- ) {
		init();
		scanf("%d%d", &N, &M );
		long long ans = 0;
		int dp[ 21 ], got[ 21 ], sum1 = 0, sum2 = 0, max1 = 0, max2 = 0;
		for( int i = 1; i <= N; i++ ) {
			scanf("\n");
			for( int j = 1; j <= M; j++ ) {
				char c;
				scanf("%c", &c );
				if( '0' <= c && c <= '9' ) {
					grid[ i ][ j ] = c - '0';
				}
				else if( c == '$' ) {
					grid[ i ][ j ] = INF;
					isb[ i ][ j ] = 1;
					build.push_back( make_node( i, j ) );
				}
				else if( c == 'X' ) {
					grid[ i ][ j ] = INF;
					s = make_node( i, j );
					isb[ i ][ j ] = 1;
				}
			}
		}
		dijkstra();
		/*for( int i = 1; i <= N; i++ ) {
			for( int j = 1; j <= M; j++ ) {
				printf("%d ", dist[ i ][ j ] );
			}
			printf("\n");
		}*/
		dp[ 0 ] = 0;
		for( int i = 1; i <= build.size(); i++ ) {
			int k = dist[ build[ i - 1 ].x ][ build[ i - 1 ].y ];
			if( k == INF ) {
				ans = -100;
			}
			sum1 += k;
			if( max( sum1 - dp[ i - 1 ], dp[ i - 1 ] ) <= max( sum1 - dp[ i - 1 ] - k, dp[ i - 1 ] + k ) ) {
				dp[ i ] = dp[ i - 1 ];
				got[ i ] = 0;
			} else {
				dp[ i ] = dp[ i - 1 ] + k;
				got[ i ] = 1;
			}
		}
		for( int i = 0; i < build.size(); i++ ) {
			printf("building %d -> %d,%d distance -> %d\n", i, build[ i ].x, build[ i ].y, dist[ build[ i ].x ][ build[ i ].y ] );
		}
		if( ans == -100 ) {
			printf("-1\n");
			continue;
		}
		sum1 = 0;
		for( int i = 1; i <= build.size(); i++ ) {
			int k = dist[ build[ i - 1 ].x ][ build[ i - 1 ].y ];
			if( got[ i ] ) {
				//printf("got the %d one !\n", i );
				sum1 += k;
				max1 = max( max1, k );
			} else {
				sum2 += k;
                                max2 = max( max2, k );
			}
		}
		ans = max( 2*sum1 - max1, 2*sum2 - max2 );
		printf("%lld\n", ans );
	}
	return 0;
}
