#include <cstdio>
#include <algorithm>

#define INF 1000001001
#define MAXN 101001

using namespace std;

struct node {
	int* A;
};

node* segtree;

void init( int n, int l, int r, int* AA )
{
	segtree[ n ].A = new int[ r - l + 1 ];
	if( l == r ) {
		segtree[ n ].A[ 1 ] = AA[ l ];
	} else {
		init( 2*n, l, ( l + r ) >> 1, AA );
		init( 2*n + 1, ( ( l + r ) >> 1 ) + 1, r, AA );
		int i, j, k;
		int n1 = ( ( l + r ) >> 1 ) - l + 1, n2 = r - ( ( l + r ) >> 1 );
		for( i = 1, j = 1, k = 1; i <= n1 && j <= n2; k++ ) {
			if( segtree[ 2*n ].A[ i ] <= segtree[ 2*n + 1 ].A[ j ] ) {
				segtree[ n ].A[ k ] = segtree[ 2*n ].A[ i++ ];
			} else {
				segtree[ n ].A[ k ] = segtree[ 2*n + 1 ].A[ j++ ];
			}
		}
		while( i <= n1 ) {
			segtree[ n ].A[ k++ ] = segtree[ 2*n ].A[ i++ ];
		}
		while( j <= n2 ) {
			segtree[ n ].A[ k++ ] = segtree[ 2*n + 1 ].A[ j++ ];
		}
	}
}

int query( int n, int l, int r, int i, int j, int x )
{
	if( l > j || r < i ) {
		return 0;
	}
	else if( i <= l && r <= j ) {
		int lo = 1, hi = r - l + 1;
		while( lo < hi ) {
			int mid = ( lo + hi ) >> 1;
			if( segtree[ n ].A[ mid ] < x ) {
				lo = mid + 1;
			} else {
				hi = mid;
			}
		}
		if( segtree[ n ].A[ lo ] > x ) {
			lo--;
		}
		return lo;
	} else {
		return query( 2*n, l, ( l + r ) >> 1, i, j, x ) + query( 2*n + 1, ( ( l + r ) >> 1 ) + 1, r, i, j , x );
	}
}

int readint() {
    int n = 0;
    char c = getchar_unlocked();
    while ( !( '0' <= c && c <= '9' ) ) {
        c = getchar_unlocked();
    }
    while ( '0' <= c && c <= '9' ) {
        n = n * 10 + c - '0';
        c = getchar_unlocked();
    }
    return n;
}

int main( void )
{
	freopen("test.in","rt",stdin);
	freopen("test2.out","wt",stdout);
	int N, cnt = 0;
	while( scanf("%d", &N ) != EOF ) {
		segtree = new node[ 4*N + 1 ];
		int Q, A[ N + 1 ];
		printf("Case %d:\n", ++cnt );
		for( int i = 1; i <= N; i++ ) A[ i ] = readint();
		init( 1, 1, N, A );
		Q = readint();
		while( Q-- ) {
			int u,v;
			u = readint();
			v = readint();
			int lo = 1, hi = N, ans = 0;
			while( lo <= hi ) {
				int mid = ( lo + hi ) >> 1;
				if( query( 1, 1, N, u, v, segtree[ 1 ].A[ mid ] ) <= ( v - u + 1 ) >> 1 ) {
					ans = mid;					
					lo = mid + 1;
				} else {
					hi = mid - 1;
				}
			}
			printf("%d\n", segtree[ 1 ].A[ ans + 1 ] );
		}
		delete [] segtree;
	}
	return 0;
}
