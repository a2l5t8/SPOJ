#include <cstdio>
#include <algorithm>
#include <ctime>

#define INF 100000000
#define MAXN 201000

using namespace std;

struct node {
	int priority, key, size;
	struct node* left;
	struct node* right;
	node(){size = 0; priority = 0; left = right = NULL;}  
        node(int newkey){size = 1; key = newkey; priority = rand() % INF; left = right = NULL;}  
        node(int _key, int pr){size = 1; key = _key; priority = pr; left = right = NULL;} 
};

struct T {
	node* R;
	T() {
		R = NULL;
		srand( time( NULL ) );
	}
	int S( node* root )
	{
		if( root == NULL ) {
			return 0;
		} else {
			return root->size;
		}
	}

	void update_size( node* &root )
	{
		if( root ) {
			root->size = S( root->left ) + S( root->right ) + 1;
		}
	}

	void left_rotate( node* &r )
	{
		node* temp = r->right;
		r->right = temp->left;
		temp->left = r;
		r = temp;
		update_size( r->left );
		update_size( r );
	}

	void right_rotate( node* &r )
	{
		node* temp = r->left;
		r->left = temp->right;
		temp->right = r;
		r = temp;
		update_size( r->right );
		update_size( r );
	}

	void insert( int key, node* &root )
	{
		if( root == NULL ) {
			root = new node( key );
			return;
		}
		if( key <= root->key ) {
			insert( key, root->left );
			if( root->priority > root->left->priority ) {
				right_rotate( root );
			}
		} else {
			insert( key, root->right );
			if( root->priority > root->right->priority ) {
				left_rotate( root );
			}
		}
		update_size( root );
	}

	void insert( int num ) {
		insert( num, R );
	}

	int kth( int k, node* root )
	{
		if( root == NULL ) {
			return -1;
		}
		int val = S( root->left ) + 1;
		if( val == k ) {
			return root->key;
		}
		else if( k < val ) {
			return kth( k, root->left );
		} return kth( k - val, root->right );
	}

	int kth( int k ) {
		return kth( k, R );
	}

	int count( int key, node* root )
	{
		if( root == NULL ) {
			return 0;
		}
		if( key <= root->key ) {
			return count( key, root->left );
		} else {
			return count( key, root->right ) + S( root->left ) + 1;
		}
	}

	int count( int key ) {
		return count( key, R );
	}
	
	void erase( int key, node* &root )
	{
		if( root == NULL ) {
			return;
		}
		//printf("key-> %d\n", key );
		//printf("root -> %d\n", root->key );
		if( key < root->key ) {
			erase( key, root->left );
		}
		else if( key > root->key ) {
			erase( key, root->right );
		} else {
			if( root->left && root->right ) {
				if( root->left->priority < root->right->priority ) {
					right_rotate( root );
				} else {
					left_rotate( root );
				}
				erase( key, root );
			} else {
				node* temp = root;
				if( root->left ) {
					root = root->left;
				}
				else if( root->right ) {
					root = root->right;
				}
				delete temp;
			}
		}
		update_size( root );
	}

	void erase( int num ) {
		erase( num, R );
	}

	bool find( int key, node* root )
	{
		if( root == NULL ) {
			return 0;
		}
		else if( root->key == key ) {
			return true;
		}
		if( key <= root->key ) {
			return find( key, root->left );
		} else {
			return find( key, root->right );
		}
	}
	
	bool find( int key ) {
		return find( key, R );
	}
};

int main( void )
{
	//freopen("test.in","rt",stdin);
	//freopen("test2.out","wt",stdout);
	int Q;
	scanf("%d", &Q );
	T treap;
	while( Q-- ) {
		char t[5];  
        	int num;  
       		scanf("%s%d",t,&num);
		if( t[ 0 ] == 'I' ) {
			//printf("inserting!\n");
			if( !treap.find( num ) ) {
				printf("inserting -> %d\n", num );
				treap.insert( num );
			}
		}
		else if( t[ 0 ] == 'K' ) {
			//printf("getting kth!\n");
			int kk = treap.kth( num );
			if( kk == -1 ) {
				printf("invalid\n");
				continue;
			}
			printf("%d\n", kk );
		}
		else if( t[ 0 ] == 'C' ) {
			//printf("counting!\n");
			printf("%d\n", treap.count( num ) );
		}
		else if( t[ 0 ] == 'D' ) {
			//printf("deleting!\n");
			if( treap.find( num ) ) {
				treap.erase( num );
				//printf("out!\n");
			}
		}
	}
	return 0;
}	
