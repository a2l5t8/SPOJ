#include <cstdio>
#include <cassert>
#include <algorithm>
 
#define MAXN 100000
#define INF 10000000000
#define MOD 10007
 
using namespace std;
 
struct node {
	int sq;
	int sum;
	int a,b,c;
	int A,B,C;
	bool flag;
};
 
struct node* segtree;
 
void init( int n, int i, int j )
{
	if( i == j ) {
		segtree[ n ].sq = i*i % MOD;
		segtree[ n ].sum = i % MOD;
	} else {
		init( 2*n, i, ( i + j ) / 2 );
		init( 2*n + 1, ( i + j ) / 2 + 1, j );
		segtree[ n ].sum = ( segtree[ 2*n ].sum + segtree[ 2*n + 1 ].sum ) % MOD;
		segtree[ n ].sq = ( segtree[ 2*n ].sq + segtree[ 2*n + 1 ].sq ) % MOD;
	}
	segtree[ n ].a = 0;
	segtree[ n ].b = 0;
	segtree[ n ].c = 0;
	segtree[ n ].A = 0;
	segtree[ n ].B = 0;
	segtree[ n ].C = 0;
	segtree[ n ].flag = false;
}
 
void unflag( int n, int i, int j )
{
	int a = ( segtree[ n ].A % MOD );
	int b = ( segtree[ n ].B % MOD );
	int c = ( segtree[ n ].C % MOD ); 
	//printf("unflagging node %d\n", n );
	if( segtree[ n ].flag ) {
		segtree[ n ].a = ( segtree[ n ].a + segtree[ n ].sq*a ) % MOD;
		segtree[ n ].b = ( segtree[ n ].b + segtree[ n ].sum*b ) % MOD;
		segtree[ n ].c = ( segtree[ n ].c + ( ( j - i + 1 ) % MOD )*c ) % MOD;
		if( i != j ) {
			segtree[ 2*n ].A = ( segtree[ 2*n ].A + a ) % MOD;
			segtree[ 2*n ].B = ( segtree[ 2*n ].B + b ) % MOD;
			segtree[ 2*n ].C = ( segtree[ 2*n ].C + c ) % MOD;
			segtree[ 2*n + 1 ].A = ( segtree[ 2*n + 1 ].A + a ) % MOD;
			segtree[ 2*n + 1 ].B = ( segtree[ 2*n + 1 ].B + b ) % MOD;
			segtree[ 2*n + 1 ].C = ( segtree[ 2*n + 1 ].C + c ) % MOD;
			segtree[ 2*n ].flag = true;
			segtree[ 2*n + 1 ].flag = true;
		}
		segtree[ n ].A = 0;
		segtree[ n ].B = 0;
		segtree[ n ].C = 0;
		segtree[ n ].flag = false;
	}
	//printf("new vals: A -> %d, B -> %d, C -> %d\n", segtree[ n ].a, segtree[ n ].b, segtree[ n ].c );
}
 
void update( int n, int i, int j, int l, int r, int a, int b, int c )
{
	//printf("updating with lazy prop (%d,%d) currently on (%d,%d)\n", l, r, i , j );
	if( i > r || j < l ) {
		unflag( n, i, j );
		return;
	}
	else if( l <= i && j <= r ) {
		//printf("all in !\n");
		segtree[ n ].A = ( segtree[ n ].A + a ) % MOD;
		segtree[ n ].B = ( segtree[ n ].B + b ) % MOD;
		segtree[ n ].C = ( segtree[ n ].C + c ) % MOD;
		segtree[ n ].flag = true;
		unflag( n, i, j );
	} else {
		unflag( n, i, j );
		update( 2*n, i, ( i + j ) / 2, l, r, a, b, c );
		update( 2*n + 1, ( i + j ) / 2 + 1, j, l, r, a, b , c );
		if( i != j ) {
			segtree[ n ].a = ( segtree[ 2*n ].a + segtree[ 2*n + 1 ].a ) % MOD;
			segtree[ n ].b = ( segtree[ 2*n ].b + segtree[ 2*n + 1 ].b ) % MOD;
			segtree[ n ].c = ( segtree[ 2*n ].c + segtree[ 2*n + 1 ].c ) % MOD;
		}
	}
}
 
int query( int n, int i, int j, int l, int r )
{
	if( i > r || j < l ) {
		return 0;
	}
	unflag( n, i, j );
	if( l <= i && j <= r ) {
		return ( segtree[ n ].a + segtree[ n ].b + segtree[ n ].c ) % MOD;
	} else {
		return ( query( 2*n, i, ( i + j ) / 2, l, r ) + query( 2*n + 1, ( i + j ) / 2 + 1, j, l , r ) ) % MOD;
	}
}
 
int main( void )
{
	int N,Q;
	scanf("%d%d", &N, &Q );
	freopen("out","wt",stdout);
	segtree = new node[ 4*N ];
	init( 1, 0, N - 1 );
	for( int i = 0; i < Q; i++ ) {
		int q;
		scanf("%d", &q);
		if( q == 0 ) {
			int u,v;
			int a,b,c;
			scanf("%d%d%d%d%d", &u, &v, &a, &b, &c );
			update( 1, 0, N - 1, u, v, a, b, c );
		} else {
			int u,v;	
			scanf("%d%d", &u, &v );
			printf("%d\n", query( 1, 0, N - 1, u, v ) );
		}
	}
	delete [] segtree;
	return 0;
}
