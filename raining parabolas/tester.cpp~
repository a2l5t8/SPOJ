#include <cstdio>
#include <algorithm>
#include <ctime>

#define MAXN 100000
#define INF 10000000000LL
#define MOD 10007

typedef unsigned long long llu;

using namespace std;

long long A[ MAXN + 1 ][ 2 ];

using namespace std;

struct node {
	llu sq;
	llu sum;
	llu a,b,c;
	llu ca,cb,cc;
	bool flag;
};

struct node* segtree;

void init( int n, int i, int j )
{
	if( i != j ) {
		init( 2*n, i, ( i + j ) / 2 );
		init( 2*n + 1, ( i + j ) / 2 + 1, j );
	}
	segtree[ n ].sq = ( llu ) j*( j + 1 )*( 2*j + 1 ) / 6 - i*( i - 1 )*( 2*i - 1 ) / 6;
	segtree[ n ].sum = ( llu )( j*(j + 1 ) ) / 2 - i*(i - 1 ) / 2;
	segtree[ n ].a = 0;
	segtree[ n ].b = 0;
	segtree[ n ].c = 0;
	segtree[ n ].flag = false;
}

void unflag( int n, int i, int j )
{
	//printf("unflagging node %d\n", n );
	if( segtree[ n ].flag ) {
		segtree[ n ].a += ( llu )segtree[ n ].sq*segtree[ n ].ca % MOD;
		segtree[ n ].a %= MOD;
		segtree[ n ].b += ( llu )segtree[ n ].sum*segtree[ n ].cb % MOD;
		segtree[ n ].b %= MOD;
		segtree[ n ].c += ( llu )( j - i + 1 )*segtree[ n ].cc % MOD;
		segtree[ n ].c %= MOD;
		if( i != j ) {
			segtree[ 2*n ].ca += segtree[ n ].ca;
			segtree[ 2*n ].cb += segtree[ n ].cb;
			segtree[ 2*n ].cc += segtree[ n ].cc;
			segtree[ 2*n + 1 ].ca += segtree[ n ].ca;
                        segtree[ 2*n + 1 ].cb += segtree[ n ].cb;
                        segtree[ 2*n + 1 ].cc += segtree[ n ].cc;
			segtree[ 2*n ].flag = true;
			segtree[ 2*n + 1 ].flag = true;
		}
		segtree[ n ].ca = 0;
		segtree[ n ].cb = 0;
		segtree[ n ].cc = 0;
		segtree[ n ].flag = false;
	}
	//printf("new val -> %d\n", segtree[ n ].val );
}

void update( int n, int i, int j, int l, int r, int a, int b, int c )
{
	//printf("updating with lazy prop (%d,%d) currently on (%d,%d)\n", l, r, i , j );
	if( i > r || j < l ) {
		unflag( n, i, j );
		return;
	}
	else if( l <= i && j <= r ) {
		//printf("all in !\n");
		segtree[ n ].ca += a;
		segtree[ n ].cb += b;
		segtree[ n ].cc += c;
		segtree[ n ].flag = true;
		unflag( n, i, j );
	} else {
		unflag( n, i, j );
		update( 2*n, i, ( i + j ) / 2, l, r, a, b, c );
		update( 2*n + 1, ( i + j ) / 2 + 1, j, l, r, a, b , c );
		if( i != j ) {
			segtree[ n ].a = segtree[ 2*n ].a % MOD + segtree[ 2*n + 1 ].a % MOD;
			segtree[ n ].a %= MOD;
			segtree[ n ].b = segtree[ 2*n ].b % MOD + segtree[ 2*n + 1 ].b % MOD;
                        segtree[ n ].b %= MOD;
			segtree[ n ].c = segtree[ 2*n ].c % MOD + segtree[ 2*n + 1 ].c % MOD;
                        segtree[ n ].c %= MOD;
		}
	}
}

long long query( int n, int i, int j, int l, int r )
{
	//printf("querying (%d,%d)\n", i, j );
	if( i > r || j < l ) {
		//printf("exiting!\n");
		return 0;
	}
	unflag( n, i, j );
	if( l <= i && j <= r ) {
		//printf("retuning %d\n", segtree[ n ].val );
		return ( segtree[ n ].a % MOD + segtree[ n ].b % MOD + segtree[ n ].c % MOD ) % MOD;
	} else {
		//printf("breaking up!\n");
		llu mVal = query( 2*n, i, ( i + j ) / 2, l, r ) % MOD + query( 2*n + 1, ( i + j ) / 2 + 1, j, l, r ) % MOD;
		mVal %= MOD;
		return mVal;
	}
}

void solve1()
{
	int N,Q;
	int cnt = 0;
	FILE* in = fopen("test.in","rt");
	fscanf(in,"%d%d", &N, &Q );
	segtree = new node[ 4*N + 4 ];
	init( 1, 0, N - 1 );
	for( int i = 0; i < Q; i++ ) {
		int q;
		fscanf(in,"%d", &q);
		if( q == 0 ) {
			int u,v,a,b,c;
			fscanf(in,"%d%d%d%d%d", &u, &v, &a, &b, &c );
			update( 1, 0, N - 1, u, v, a, b, c );
		} else {
			int u,v;	
			fscanf(in,"%d%d", &u, &v );
			A[ cnt++ ][ 0 ] = query( 1, 0, N - 1, u, v ) % MOD;
		}
	}
	delete [] segtree;
}

void solve2()
{
	int N,Q, cnt = 0;
	FILE* in = fopen("test.in","rt");
	fscanf(in,"%d%d", &N, &Q );
	long long m[ MAXN + 1 ] = { 0 };
	for( int i = 0; i < Q; i++ ) {
                int q;
                scanf("%d", &q);
                if( q == 0 ) {
                        int u,v,a,b,c;
			fscanf(in,"%d%d%d%d%d", &u,&v,&a,&b,&c );
                        for( int j = u; j <= v; j++ ) {
				m[ j ] += a*j*j + b*j + c;
			}
                } else {
			long long ans = 0;
                        int u,v;
                        fscanf(in,"%d%d", &u, &v );
                        for( int j = u; j <= v; j++ ) {
				ans += m[ j ];
				ans %= MOD;
			}
			A[ cnt++ ][ 1 ] = ans;
		}
	}
}

int main( void )
{
	srand( time( NULL ) );
	int cnt = 0;
	bool status = true;
	while( status ) {
		FILE* pfin = fopen("test.in","wt");
		int N,Q, k = 0;
		N = rand() % 5000 + 1;
		Q = rand() % 5000 + 1;
		fprintf(pfin,"%d %d\n", N, Q );
		for( int i =0; i < Q; i++ ) {
			int q = rand() % 2;
			fprintf(pfin,"%d ",q );
			if( q == 0 ) {
				int u,v,a,b,c;
				u = rand() % N;
				v = rand() % N;
				if( u > v ) {
					swap( u, v ) ;
				}
				a = rand() % 10007;
				b = rand() % 10007;
				c = rand() % 10007;
				fprintf(pfin,"%d %d %d %d %d\n", u,v,a,b,c );
			} else {
				int u,v;
				if( u > v ) {
					swap( u, v ) ;
				}
				u = rand() % N;
				v = rand() % N;
				fprintf(pfin,"%d %d\n", u, v );
				k++;
			}
		}	
		fclose( pfin);
		break;
		solve1();
		solve2();
		for( int i = 0; i < k; i++ ) {
			if( A[ i ][ 0 ] != A[ i ][ 1 ] ) {
				printf("%lld != %lld\n", A[ i ][ 0 ], A[ i ][ 1 ] );
				status = false;
			}
		}
		printf("got %d\n", cnt++ );
	}
	return 0;
}
