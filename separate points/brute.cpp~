#include <cstdio>
#include <algorithm>
#include <stack>
#include <cmath>
#include <map>
#include <utility>
 
#define INF 500
 
using namespace std;
 
struct pt {
	int x,y,idx;
};

bool difsign( int a, int b )
{
	return ( a < 0 && b > 0 ) || ( a > 0 && b < 0 );
}

long long CCW( pt a, pt b, pt c )
{
	return ( b.x - a.x ) * ( c.y - a.y ) - ( c.x - a.x ) * ( b.y - a.y );
}

bool onsegment( pt a, pt b, pt c )
{
	if( min( a.x, b.x ) <= c.x && c.x <= max( a.x, b.x ) && min( a.y, b.y ) <= c.y && c.y <= max( a.y, b.y ) ) {
		return true;
	} else {
		return false;
	}
}

bool intersect( pt a, pt b, pt c, pt d )
{
	int d1 = CCW( c, d, a );
	int d2 = CCW( c, d, b );
	int d3 = CCW( a, b, c );
	int d4 = CCW( a, b, d );
	return difsign( CCW( a, b, c ) , CCW( a,b, d  ) ) && difsign( CCW( c, d, a ), CCW( c,d, b ));
	if(!d3 && onsegment(a, b, c)) return true;
	if(!d4 && onsegment(a, b, d)) return true;
	if(!d1 && onsegment(c, d, a)) return true;
	if(!d2 && onsegment(c, d, b)) return true;
}

void solve( int cnt )
{
	int N,M;
	scanf("%d%d", &N, &M );
	bool status = true;
	if( N == 0 && M == 0 ) {
		exit(0);
	}
	pt Ni[ N ], Mi[ M ];
	for( int i = 0; i < N; i++ ) {
		scanf("%d%d", &Ni[ i ].x, &Ni[ i ].y );
		Ni[ i ].idx = i + 1;
	}
	for( int i = 0; i < M; i++ ) {
		scanf("%d%d", &Mi[ i ].x, &Mi[ i ].y );
		Mi[ i ].idx = N + i + 1;
	}
	for( int i = 0; i < N; i++ ) {
		for( int j = 0; j < N; j++ ) {
			for( int k = 0; k < M; k++ ) {
				for( int l = 0; l < M; l++ ) {
					if( intersect( Ni[ i ], Ni[ j ], Mi[ k ], Mi[ l ] ) ) {
						status = false;
					}
				}
			}
		}
	}
	printf("%s\n", status?"YES":"NO" );
} 

int main( void )
{
	int cnt = 1;
	freopen("test.in","rt",stdin);
	freopen("test.out", "wt",stdout);
	while( true ) {
		solve(cnt);
		cnt++;
	}
	return 0;
}
