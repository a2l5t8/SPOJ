#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>

#define BUCK 330
#define MAXN BUCK * BUCK + 10

#define X first
#define Y second
#define mp make_pair
#define pb push_back

using namespace std;

typedef pair< int, int > pii;

struct query {
    pii interval;
    int idx;
};

bool operator<( query A, query B )
{
    return A.interval < B.interval;
}

int A[ MAXN + 1 ], ans[ MAXN + 1 ], occ[ BUCK + 10 ][ MAXN + 1 ];
vector< query > queries;

int total[ MAXN + 1 ] = { 0 }, inbucket[ MAXN + 1 ] = { 0 };

int main() {
    freopen("test.in","rt",stdin);
    freopen("test.out","wt",stdout);
    int N, Q, u, v, cnt = 0;
    scanf("%d%d", &N, &Q );
    for( int i = 1; i <= N; i++ ) {
        scanf("%d", &A[ i ] );
    }
    for( int i = 1; i <= Q; i++ ) {
        scanf("%d%d", &u, &v );
        queries.pb( ( query ) { mp( u + 1, v + 1 ), i } );
    }
    queries.pb( ( query ) { mp( MAXN, MAXN ), MAXN } );
    
    sort( queries.begin(), queries.end() );
    for( int b = 1; BUCK * ( b - 1 ) + 1 <= N && cnt <= Q; b++ ) {
        int sol = 0, max_out = 0;
        vector< pii > ends;
        vector< int > elements;
        while( cnt <= Q && queries[ cnt ].interval.X <= BUCK * b ) {
            ends.pb( mp( queries[ cnt ].interval.Y, cnt ) );
            cnt++;
        }
        for( int i = BUCK * ( b - 1 ) + 1; i <= BUCK * b && i <= N; i++ ) {
            for( int j = 1; j <= i - BUCK * ( b - 1 ); j++ ) {
                occ[ i - BUCK * ( b - 1 ) ][ A[ j + BUCK * ( b - 1 ) ] ]++;
            }
            if( !inbucket[ A[ i ] ] ) elements.pb( A[ i ] );
            inbucket[ A[ i ] ] = true;
        }
        sort( ends.begin(), ends.end() );
        int pointer = BUCK * ( b - 1 ) + 1;
        for( int i = 0; i < ends.size(); i++ ) {
            sol = 0;
            while( pointer <= ends[ i ].X ) {
                total[ A[ pointer ] ]++;
                if( !inbucket[ A[ pointer ] ] ) max_out = max( max_out, total[ A[ pointer ] ] );
                pointer++;
            }
            sol = max( sol, max_out );
            for( int j = 0; j < ( int )elements.size(); j++ ) {
                int original = queries[ ends[ i ].Y ].interval.X, myelem = elements[ j ];
                sol = max( sol, total[ myelem ] - occ[ original - BUCK * ( b - 1 ) - 1 ][ myelem ] );
            }
            ans[ queries[ ends[ i ].Y ].idx ] = sol;
        }
    }
    for( int i = 1; i <= Q; i++ ) {
        printf("%d\n", ans[ i ] );
    }
    return 0;
}
