/*
 * VMILI.cpp
 * SPOJ
 *  Created on: Apr 25, 2012
 *      Author: mohammadkotb
 */
 
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <complex>
#include <algorithm>
#include <cmath>
#include <stack>
#include <vector>
#include <cstring>
 
using namespace std;
 
typedef long long ll;
typedef complex<ll> point;
#define EPS 1.0e-7
#define X real()
#define Y imag()
#define vec(a,b) ((b)-(a))
#define length(a) hypot((a).X, (a).Y)
#define distance(a,b) length(vec((a),(b)))
#define dot(a,b) ((conj((a))) * (b)).real()
#define cross(a,b) ((conj((a))) * (b)).imag()
 
 
 
typedef struct hole {
	point pt;
	int pos;
 
	hole() {}
	hole(ll x, ll y, int p) {
		pt = point(x,y);
		pos = p;
	}
} hole;
 
hole ref;
bool cmp(const hole& a, const hole& b) {
	ll crss = cross(vec(ref.pt,a.pt), vec(ref.pt,b.pt));
	if (crss > 0) return true;
	else if (crss < 0) return false;
	else {
		double d1 = distance(a.pt, ref.pt);
		double d2 = distance(b.pt, ref.pt);
		if (fabs(d1-d2) < EPS) return true;
		else if (d1 < d2) return true;
		else if (d1 > d2) return false;
	}
	return false;
}
 
void convexHull(vector<hole>& points, vector<hole>& result) {
	int index = 0;
	for (int i = 0; i < points.size(); i++) {
		if (points[i].pt.Y < points[index].pt.Y || (points[i].pt.Y == points[index].pt.Y && points[i].pt.X < points[index].pt.X)) {
			index = i;
		}
	}
	ref = points[index];
	points[index] = points[0];
	points[0] = ref;
 
	sort(points.begin(), points.end(), cmp);
 
	if (points.size() < 3) {
		for (int i = 0; i < points.size(); i++) result.push_back(points[i]);
		return;
	}
 
	stack<hole> stck;
	stck.push(points[0]); stck.push(points[1]);
	for (int i = 2; i < points.size(); i++) {
		hole first = stck.top(); stck.pop();
		hole org = stck.top();
 
		ll crss = cross(vec(org.pt,first.pt),vec(org.pt,points[i].pt));
		if (crss > 0) {
			stck.push(first); stck.push(points[i]);
		} else if (crss < 0) {
			i--;
		} else {
			double d1 = distance(org.pt, first.pt);
			double d2 = distance(org.pt, points[i].pt);
 
			if (fabs(d1-d2) <= EPS) {
				stck.push(first); stck.push(points[i]);
			} else if (d1 < d2) {
				stck.push(first); stck.push(points[i]);
			} else if (d1 > d2) {
				stck.push(points[i]); stck.push(first);
			}
		}
	}
 
	while (!stck.empty()) {
		result.push_back(stck.top()); stck.pop();
	}
}
 
 
vector<hole> holes;
int N;
bool vis[5000];
 
int main() {
	cin >> N;
	holes.clear();
	for (int i = 0; i < N; i++) {
		ll x,y; cin >> x >> y;
		holes.push_back(hole(x,y,i));
	}
	memset(vis,false,sizeof(vis));
	int rem = N;
	int counter = 0;
	do {
		vector<hole> pts;
		for (int i = 0; i < N; i++) if (!vis[i]) {
			pts.push_back(holes[i]);
		}
 
		vector<hole> result;
		convexHull(pts, result);
 		//printf("result -> %d\n", result.size() );
		for (int i = 0; i < result.size(); i++) {
			rem--;
			vis[result[i].pos] = true;
		}
		if (result.size() > 2)
			counter++;
	} while (rem > 0);
	printf("%d\n", counter);
	return 0;
}
