#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>

#define X first
#define Y second
#define pb push_back
#define mp make_pair

#define MAXN 100100

using namespace std;

typedef pair< int, int > pii;

int par[ MAXN + 1 ], depth[ MAXN + 1 ], chain[ MAXN + 1 ], head[ MAXN + 1 ], subtree[ MAXN + 1 ], chaind[ MAXN + 1 ], size[ MAXN + 1 ];
int chain_num = 1;

vector< int > tree[ MAXN + 1 ];
int** BIT[ MAXN + 1 ];
vector< pii > edges;

int rep[ MAXN + 1 ], rank[ MAXN + 1 ], crucial[ MAXN + 1 ]; // dsu

int find( int u ) {
    if( u == rep[ u ] ) return u;
    else return rep[ u ] = find( rep[ u ] );
}

void Union( int u, int v ) {
    u = find( u );
    v = find( v );
    if( rank[ u ] < rank[ v ] ) {
        rep[ u ] = v;
    } else {
        rep[ v ] = u;
        if( rank[ u ] == rank[ v ] ) rank[ u ]++;
    }
}

void init( int s, int p, int d )
{
	depth[ s ] = d;
	subtree[ s ] = 1;
	par[ s ] = p;
	for( int i = 0; i < tree[ s ].size(); i++ ) {
		int v = tree[ s ][ i ];
		if( v != p ) {
			init( v, s, d + 1 );
			subtree[ s ] += subtree[ v ];
		}
	}
}

void init_segtree()
{
	for( int i = 1; i <= chain_num; i++ ) {
		BIT[ i ] = new int*[ size[ i ] + 10 ];
		for( int j = 1; j <= size[ i ]; j++ ) {
			BIT[ i ][ j ] = new int[ 2 ];	
		}
    }
}

int query( int ch, int X, int d ) {
	int ans = 0;
	while( X > 0 ) {
		ans += BIT[ ch ][ X ][ d ];
		X -= ( X & -X );
	}
	return ans;
}
 
void update( int ch, int X, int val, int d ) {
	while( X <= N ) {
		BIT[ ch ][ X ][ d ] = val;
		X += ( X & -X );
	}
}
 
void update_range( int ch, int i, int j, int val ) {
	update( ch, i, val, 0 );
	update( ch, j + 1, -val, 0 );
	update( ch, i, ( i - 1 ) * val, 1 );
	update( ch, j + 1, -( i - 1 ) * val - val * ( j - i + 1 ), 1 );
}
 
int query_range( int ch, int i, int j ) {
	int suma = 0, sumb = 0;
	suma = query( ch, i - 1, 0 ) * ( i - 1 ) - query( ch, i - 1, 1 );
	sumb = query( ch, j, 0 ) * j - query( ch, j, 1 );
	return suma - sumb;
}

void heavy_light( int s, int d )
{
	chain[ s ] = chain_num;
	chaind[ s ] = d;
	if( d == 1 ) {
		head[ chain_num ] = s;
	}
	size[ chain_num ] = d;
	int node = 0;
	for( int i = 0; i < tree[ s ].size(); i++ ) {
		int v = tree[ s ][ i ];
		if( v == par[ s ] ) continue;
		if( subtree[ v ] >= subtree[ node ] ) {
			node = v;
		}
	}
	if( node ) {
		heavy_light( node, d + 1 );
	}
	for( int i = 0; i < tree[ s ].size(); i++ ) {
		int v = tree[ s ][ i ];
		if( v == par[ s ] || node == v ) continue;
		chain_num++;
		heavy_light( v, 1 );
	}
}

int LCA( int u, int v )
{
	do {
		if( chain[ u ] == chain[ v ] ) {
			if( depth[ u ] < depth[ v ] ) {
				return u;
			}
			return v;
		}
		int newu = par[ head[ chain[ u ] ] ], newv = par[ head[ chain[ v ] ] ];
		if( depth[ newu ] >= depth[ newv ] ) {
			u = newu;
		} else {
			v = newv;
		}
	} while( true );
}

int doit( int u, int v ) {
    int ans = 0;
    while( chain[ u ] != chain[ v ] ) {
        int H = head[ chain[ u ] ];
        ans += query_range( chain[ u ], 1, chaind[ u ] );
        update_range( chain[ u ], 1, chaind[ u ], 1 );
        u = par[ H ];
    }
    if( u == v ) return ans;
    ans += query_range( chain[ u ], chaind[ v ] + 1, chaind[ u ] );
    update_range( chain[ u ], chaind[ v ] + 1, chaind[ u ], 1 );
    return ans;
}

int readint() {
    int n = 0;
    char c = getchar_unlocked();
    while ( !( '0' <= c && c <= '9' ) ) {
        c = getchar_unlocked();
    }
    while ( '0' <= c && c <= '9' ) {
        n = n * 10 + c - '0';
        c = getchar_unlocked();
    }
    return n;
}

int main( void ) {
    int T;
    T = readint();
    while( T-- ) {
        int N, M, u, v, ans = 0;
        N = readint();
        M = readint();
        for( int i = 1; i <= N; i++ ) {
            tree[ i ].clear();
            rank[ i ] = 1;
            rep[ i ] = i;
        }
        for( int i = 1; i <= M; i++ ) {
            u = readint();
            v = readint();
            u++, v++;
            edges.pb( mp( u, v ) );
            if( find( u ) != find( v ) ) {
                tree[ u ].pb( v );
                tree[ v ].pb( u );
                Union( u, v );
                crucial[ i ] = false;
            } else {
                crucial[ i ] = true;
            }
        }
        init( 1, -1, 1 );
        heavy_light( 1, 1 );
        init_segtree();
        for( int i = 0; i < M; i++ ) {
            int u = edges[ i ].X, v = edges[ i ].Y;
            if( !crucial[ i + 1 ] ) {
                ans++;
            } else {
                int lca = LCA( u, v );
                ans -= doit( u, lca );
                ans -= doit( v, lca );
            }
            printf("%d\n", ans );
        }
        chain_num = 1;
        edges.clear();
    }
    return 0;
}
