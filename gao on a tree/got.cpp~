#include <cstdio>
#include <algorithm>
#include <vector>
#include <cstring>
#include <queue>
#include <set>

#define MAXN 101000
#define pb push_back

#define X first
#define Y second
#define mp make_pair

using namespace std;

typedef pair< int, int > pii;

int A[ MAXN + 1 ], depth[ MAXN + 1 ], subtree[ MAXN + 1 ], parent[ MAXN + 1 ];
int chain[ MAXN + 1 ], head[ MAXN + 1 ], position[ MAXN + 1 ], chain_num = 1;

vector< int > T[ MAXN + 1 ];
vector< pii > S[ MAXN + 1 ];

void dfs( int u, int d, int p )
{
	subtree[ u ] = 1;
	parent[ u ] = p;
	depth[ u ] = d;
	for( int i = 0; i < T[ u ].size(); i++ ) {
		int v = T[ u ][ i ];
		if( v == p ) continue;
		dfs( v, d + 1, u );
	}
}

void HLD( int u, int d )
{
	chain[ u ] = chain_num;
	position[ u ] = d;
	S[ chain[ u ] ].pb( mp( A[ u ], d ) );
	if( d == 1 ) head[ chain[ u ] ] = u;
	int node = 0;
	for( int i = 0; i < T[ u ].size(); i++ ) {
		int v = T[ u ][ i ];
		if( v == parent[ u ] ) continue;
		if( subtree[ v ] > subtree[ node ] ) node = v;
	}
	if( node ) HLD( node, d + 1 );
	for( int i = 0; i < T[ u ].size(); i++ ) {
		int v = T[ u ][ i ];
		if( v == node || v == parent[ u ] ) continue;
		chain_num++;
		HLD( v, 1 );
	}
}

int LCA( int u, int v )
{
	do {
		if( chain[ u ] == chain[ v ] ) {
			return depth[ u ] > depth[ v ] ? v : u;
		}
		int uu = parent[ head[ chain[ u ] ] ], vv = parent[ head[ chain[ v ] ] ];
		printf("u -> %d, v -> %d\n", u, v );
		if( depth[ uu ] > depth[ vv ] ) u = uu;
		else v = vv;
	} while( true );
}

bool find( int u, int v, int val )
{
	int lca = LCA( u, v ), lo, hi, mid, ans;
	printf("lca -> %d\n", lca );
	while( chain[ lca ] != chain[ u ] ) {
		lo = 0, hi = S[ chain[ u ] ].size() - 1, ans = -1;
		while( lo <= hi ) {
			mid = ( lo + hi ) / 2;	
			if( S[ chain[ u ] ][ mid ].X < val ) lo = mid + 1;
			else {
				hi = mid - 1;
				ans = mid;
			}
		}
		if( ans != -1 && S[ chain[ u ] ][ ans ].X == val && S[ chain[ u ] ][ ans ].Y <= position[ u ] ) return true;
		u = parent[ head[ chain[ u ] ] ];
	}
	lo = 0, hi = S[ chain[ u ] ].size() - 1, ans = -1;
	while( lo <= hi ) {
		mid = ( lo + hi ) / 2;
		if( S[ chain[ u ] ][ mid ].X > val ) hi = mid - 1;
		else if( S[ chain[ u ] ][ mid ].X < val ) lo = mid + 1;
		else {
			if( S[ chain[ u ] ][ mid ].Y >= position[ lca ] ) {
				ans = mid;
				hi = mid - 1;
			} else lo = mid + 1;
		}
	}
	if( ans != -1 && S[ chain[ u ] ][ ans ].X == val ) return true;
	while( chain[ lca ] != chain[ v ] ) {
		lo = 0, hi = S[ chain[ v ] ].size() - 1, ans = -1;
		while( lo <= hi ) {
			mid = ( lo + hi ) / 2;	
			if( S[ chain[ v ] ][ mid ].X < val ) lo = mid + 1;
			else {
				hi = mid - 1;
				ans = mid;
			}
		}
		if( ans != -1 && S[ chain[ v ] ][ ans ].X == val && S[ chain[ v ] ][ ans ].Y <= position[ v ] ) return true;
		v = parent[ head[ chain[ v ] ] ];
	}
	lo = 0, hi = S[ chain[ v ] ].size() - 1, ans = -1;
	while( lo <= hi ) {
		mid = ( lo + hi ) / 2;
		if( S[ chain[ v ] ][ mid ].X > val ) hi = mid - 1;
		else if( S[ chain[ v ] ][ mid ].X < val ) lo = mid + 1;
		else {
			if( S[ chain[ v ] ][ mid ].Y >= position[ lca ] ) {
				ans = mid;
				hi = mid - 1;
			} else lo = mid + 1;
		}
	}
	if( ans != -1 && S[ chain[ v ] ][ ans ].X == val ) return true;
	return false;	
}

void initialize()
{
	for( int i = 1; i <= chain_num; i++ ) {
		sort( S[ i ].begin(), S[ i ].end() );
		printf("chain -> %d:", i );
		for( int j = 0; j < S[ i ].size(); j++ ) {
			printf(" (%d,%d)", S[ i ][ j ].X, S[ i ][ j ].Y );
		}
		printf("\n");
	}
}

int main( void )
{
	int N, Q;
	while( scanf("%d%d", &N, &Q ) != EOF ) {
		for( int i = 1; i <= N; i++ ) {
			T[ i ].clear();
			S[ i ].clear();
		}
		memset( head, 0, sizeof( head ) );
		memset( parent, 0, sizeof( parent ) );
		memset( depth, 0, sizeof( depth ) );
		memset( chain, 0, sizeof( chain ) );
		memset( position, 0, sizeof( position ) );
		memset( A, 0, sizeof( position ) );
		memset( subtree, 0, sizeof( subtree ) );
		chain_num = 1;
		int u, v, vv;
		for( int i = 1; i <= N; i++ ) scanf("%d", &A[ i ] );
		for( int i = 0; i < N - 1; i++ ) {
			scanf("%d%d", &u, &v );
			T[ u ].pb( v );
			T[ v ].pb( u );
		}
		dfs( 1, 1, -1 );
		HLD( 1, 1 );
		initialize();
		while( Q-- ) {
			scanf("%d%d%d", &u, &v, &vv );
			if( find( u, v, vv ) ) printf("Find\n");
			else printf("NotFind\n");
		}
		printf("\n");
	}
	return 0;
}
